<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[快速排序算法]]></title>
    <url>%2F2018%2F09%2F25%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序 快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。 步骤为：从数列中挑出一个元素，称为“基准”（pivot），重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 在平均状况下，排序nn个项目要 O(nlog⁡n){\displaystyle \ O(n\log n)}（大O符号）次比较。在最坏状况下则需要O(n2){\displaystyle O(n^{2})}次比较，但这种状况并不常见。事实上，快速排序Θ(nlog⁡n){\displaystyle \Theta (n\log n)}通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
</search>
